var documenterSearchIndex = {"docs":
[{"location":"howto/add_to_model/#Add-approximation-to-model","page":"Add constraints to a model","title":"Add approximation to model","text":"","category":"section"},{"location":"howto/add_to_model/","page":"Add constraints to a model","title":"Add constraints to a model","text":"A piecewise-affine approximation Ìƒð“ â‰ˆ ð’»(ð”) can be added to a JuMP model for optimization purposes. In that case, the optimization variables ð” will denote the coordinates in the domain whereas the approximate value of function ð’» will be represented by Ìƒð“.","category":"page"},{"location":"howto/add_to_model/","page":"Add constraints to a model","title":"Add constraints to a model","text":"The code below creates a piecewise affine approximate to ð“Â² on the interval [-1,1] using the JuMP variable ð“. The piecewise affine approximation is linked the other variable in the model ð“. The objective is set as the minimization of this variable suject to ð“ being greater or equal than 0.5. After the optimization of the constrained problem, the optimal value of ð“ is 0.2653.","category":"page"},{"location":"howto/add_to_model/","page":"Add constraints to a model","title":"Add constraints to a model","text":"using JuMP, PiecewiseAffineApprox, HiGHS\n\n\noptimizer = optimizer_with_attributes(HiGHS.Optimizer, MOI.Silent()=>true)\nm = Model(optimizer)\n@variable(m, x)\n# Create a piecewise linear approximation to x^2 on the interval [-1, 1]\npwa = approx(x -> x[1]^2, [(-1, 1)], Convex(), MILP(optimizer = optimizer, planes=5))\n# Add the pwa function to the model\nz = pwaffine(m, x, pwa)\n# Minimize\n@objective(m, Min, z)\n# Check approximation/solution at x = 0.5\n@constraint(m, x >= 0.5)\noptimize!(m);\nround(value(z); digits=4)","category":"page"},{"location":"howto/add_to_model/","page":"Add constraints to a model","title":"Add constraints to a model","text":"A piecewise affine approximation can be also be linked to existing variables in an existing JuMP model. In the following code, a 3D piecewise affine approximation is obtained for existing variables of a model (xvar and yvar). The approximation is constructed for a given dataset (X,z) and then linked to a JuMP model, which is optimized in the sequence.","category":"page"},{"location":"howto/add_to_model/","page":"Add constraints to a model","title":"Add constraints to a model","text":"using JuMP, PiecewiseAffineApprox, HiGHS\noptimizer = optimizer_with_attributes(HiGHS.Optimizer, MOI.Silent()=>true)\n\nxg = [i for i âˆˆ -1:0.5:1]\nyg = [j for j âˆˆ -1:0.5:1]\nX = [repeat(xg, inner = [size(yg, 1)]) repeat(yg, outer = [size(xg, 1)])]\nz = X[:, 1] .^ 2 + X[:, 2] .^ 2\n\nnp = 17\n\nm = Model()\n@variable(m, xvar)\n@variable(m, yvar)\n@variable(m, approx_f)\n\ntuple_var = (xvar, yvar)\n\ny = pwaffine(\n    m,\n    tuple_var,\n    approx(\n        FunctionEvaluations(tuple.(eachcol(X)...), z),\n        Convex(),\n        MILP(\n            optimizer = optimizer,\n            planes = np,\n            strict = :outer,\n            metric = :l1,\n        ),\n    );\n    z = approx_f,\n)\n\n@objective(m, Min, y)\nset_optimizer(m, optimizer)\n@constraint(m, xvar == âˆš0.5)\n@constraint(m, yvar == âˆš0.5)\noptimize!(m)\nround(value.(y))","category":"page"},{"location":"reference/api/","page":"API reference","title":"API reference","text":"CurrentModule = PiecewiseAffineApprox","category":"page"},{"location":"reference/api/#Algorithms","page":"API reference","title":"Algorithms","text":"","category":"section"},{"location":"reference/api/","page":"API reference","title":"API reference","text":"#FullOrderFitting\n#Heuristic\n#Interpol\n#Optimized\n#ProgressiveFitting","category":"page"},{"location":"reference/api/#Other-types","page":"API reference","title":"Other types","text":"","category":"section"},{"location":"reference/api/","page":"API reference","title":"API reference","text":"\n#Convex     # Missing docstring\n#Concave    # Missing docstring\nPlane\nFunctionEvaluations\nPWAFunc","category":"page"},{"location":"reference/api/#PiecewiseAffineApprox.Plane","page":"API reference","title":"PiecewiseAffineApprox.Plane","text":"Plane{D}\n\nA D-dimensional hyperplane (Î±áµ€x = Î²).\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#PiecewiseAffineApprox.FunctionEvaluations","page":"API reference","title":"PiecewiseAffineApprox.FunctionEvaluations","text":"FunctionEvaluations{D}\n\nA structure holding a set of points and the associated function values for a function f:â„œá´° â†’ â„œ.\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#PiecewiseAffineApprox.PWAFunc","page":"API reference","title":"PiecewiseAffineApprox.PWAFunc","text":"PWAFunc{C<:Curvature,D}\n\nA piecewise linear function that can be either convex and concave represented by a set of (hyper)planes.\n\nIf the curvature of the function is convex, the piecewise linear Function is defined as the pointwise maximum over the planes. A concave pwa function is handled by storing its negative and negating when evaluting.\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#Functions","page":"API reference","title":"Functions","text":"","category":"section"},{"location":"reference/api/","page":"API reference","title":"API reference","text":"approx\nenforce_curvature\nevaluate\npwaffine","category":"page"},{"location":"reference/api/#PiecewiseAffineApprox.approx","page":"API reference","title":"PiecewiseAffineApprox.approx","text":"approx(input::FunctionEvaluations{D}, c::Curvature, a::Algorithm)\n\nReturn PWAFunc{Convex,D} or PWAFunc{Concave,D} depending on c, approximating the input points in D dimensions\n\n\n\n\n\napprox(input::FunctionEvaluations, c::Convex, a::Cluster)\n\nApproximate using a heuristic that works for general dimensions.\n\nAdditional keyword arguments:\n\ntrials: number of restarts (default = 20)\nitlim: max refining iterations in each trial (default = 50),\n\n\n\n\n\napprox(input::FunctionEvaluations, c::Convex, a::Progressive)\n\nApproximate using a progressive fitting heuristic that adds planes until a specified error tolerance is met.\n\nThis algorithm requires that the data points provided are samples from a convex function.\n\n\n\n\n\napprox(input::FunctionEvaluations, c::Convex, a::FullOrder)\n\nApproximate using full order fitting that adds planes for all sample points.\n\nThis algorithm requires that the data points provided are samples from a convex function.\n\n\n\n\n\napprox(f::Function, bbox::Vector{<:Tuple}, c::Curvature, a::Algorithm;  kwargs...)\n\nApproximate the function using a uniform sampling over the bounding box bbox\n\nAdditional keyword arguments:\n\nnsample: the number of points used in each dimension (default = 10)\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#PiecewiseAffineApprox.enforce_curvature","page":"API reference","title":"PiecewiseAffineApprox.enforce_curvature","text":"enforce_curvature(f::FunctionEvaluations, curvature::Curvature, optimizer, metric = :l1)\n\nCreate a slightly perturbed version of the function values to ensure that the data points can be interpolated by a convex/concave piecewise affine function.\n\nEnforcing the curvature is performed using a linear optimization problem that adjust the function values and tries to minimize the total deviation. The total deviation can be measured in different metrics specified by the metric parameter. This function can be useful as a pre-step for running the full-order and progressive fitting heuristics that require data points that are convex/concave in this sense.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#PiecewiseAffineApprox.evaluate","page":"API reference","title":"PiecewiseAffineApprox.evaluate","text":"evaluate(pwa::PWAFunc{Convex,D}, x) where {D}\n\nEvaluate the convex piecewise linear function at the point x.\n\n\n\n\n\nevaluate(pwa::PWAFunc{Concave,D}, x) where {D}\n\nEvaluate the concave piecewise linear function at the point x.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#PiecewiseAffineApprox.pwaffine","page":"API reference","title":"PiecewiseAffineApprox.pwaffine","text":"pwaffine(m::JuMP.Model, x::Tuple, pwa::PWAFunc{C,D}; z=nothing, kwargs...) where {C,D}\n\nAdd constraints to JuMP-model m for JuMP-variable z as a   piecewise linear function/approximation pwa of JuMP-variables x    \n\n\n\n\n\n","category":"function"},{"location":"background/background/#Background","page":"Background","title":"Background","text":"","category":"section"},{"location":"howto/approximate_function/#Approximate-a-function","page":"Approximate a function","title":"Approximate a function","text":"","category":"section"},{"location":"howto/approximate_function/","page":"Approximate a function","title":"Approximate a function","text":"Piecewise affine approximations can be obtained either for a given function ð’»(x) or for a set of sampled points ð’³ with their corresponding function values ð’µ = {f(x): âˆ€x âˆˆ ð’³}. Both methods have their applicability depending on the context and the specific application requirements. Methods that use the functions directly can be updated iteratively in real-time applications whereas approximations that use a collection of points may be more relevant when a dataset is provided for off-line construction of the approximate functions prior to optimization.","category":"page"},{"location":"howto/approximate_function/","page":"Approximate a function","title":"Approximate a function","text":"For piecewise-affine approximations obtained from a pre-defined function, PWA provides a function called approx() which receives as the first arguments the sampling function and the region in the domain for the sampling. The following code creates a convex piecewise affine approximation to ð“Â² on the interval [-1,1] with 5 planes, or segments for this unidimensional case. Notice that the domain [-1,1] will be sampled uniformly thereby splitting the feasible region into 5 segments with corresponding 6 points.","category":"page"},{"location":"howto/approximate_function/","page":"Approximate a function","title":"Approximate a function","text":"\nusing JuMP, PiecewiseAffineApprox, HiGHS\noptimizer = optimizer_with_attributes(HiGHS.Optimizer, MOI.Silent()=>true)\n\nm = Model(optimizer)\n@variable(m, x)\npwa = approx(x -> sum(x.^2), [(-1, 1)], Convex(), MILP(optimizer = optimizer, planes=5))\nz = pwaffine(m, x, pwa)\n\ntypeof(z)\n\n# output\nVariableRef (alias for GenericVariableRef{Float64})","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"PiecewiseAffineApprox is a package designed to compute and add convex (or concave) piecewise linear approximations of functions or a set of points to optimization models modelled in JuMP. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"This package provides three main methods to fit a set of points: ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"creates and solves a MILP to fit a set of points, and adds the resulting linear constraints to the optimization model. This method is partially based on Toriello & Vielma, 2012. \nuses a heuristic to fit the set of points. This method is based on Magnani & Boyd, 2009.\na progressive heuristic to add planes until a certain accuracy is met. This method is based on Kazda & Li, 2024","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"For non-convex functions, consider using PiecewiseLinearOpt.jl.","category":"page"},{"location":"#Usage","page":"Introduction","title":"Usage","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"using JuMP, PiecewiseAffineApprox, HiGHS\noptimizer = optimizer_with_attributes(HiGHS.Optimizer, MOI.Silent()=>true)\n\nm = Model(optimizer)\n@variable(m, x)\n# Create a piecewise linear approximation to x^2 on the interval [-1, 1]\npwa = approx(x -> x[1]^2, [(-1, 1)], Convex(), MILP(;optimizer, planes=5))\n# Add the pwa function to the model\nz = pwaffine(m, x, pwa)\n# Minimize\n@objective(m, Min, z)\n# Check approximation/solution at x = 0.5\n@constraint(m, x >= 0.5)\noptimize!(m)\nround(value(z), digits=4)\n\n# output\n0.2653","category":"page"},{"location":"#Visualization","page":"Introduction","title":"Visualization","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"To keep dependencies light, PiecewiseAffineApprox does not include plotting by default. If the Makie or Plots package is loaded before using the module, some simple plotting routines will be available","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The following demonstrates the use of the plotting functions with Makie:","category":"page"},{"location":"#2D","page":"Introduction","title":"2D","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"using PiecewiseAffineApprox, CairoMakie, HiGHS, JuMP\noptimizer = optimizer_with_attributes(HiGHS.Optimizer, MOI.Silent()=>true)\nx = LinRange(0, 1, 20)\nf(x) = first(x)^2\npwa = approx(f, [(0, 1)], Convex(), MILP(;optimizer, planes = 3))\np = plot(x, f.(x), pwa)\n\nsave(\"approx.svg\", p)\n\n# output\nCairoMakie.Screen{SVG}","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: )","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Animation showing the accuracy when adding more cuts:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"<video autoplay loop muted>\n<source src=\"assets/approxanim.mp4\" type=\"video/mp4\" />\nvideo\n</video>","category":"page"},{"location":"#3D","page":"Introduction","title":"3D","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Approximation of 3D function","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"<video autoplay loop muted>\n<source src=\"assets/rotation.mp4\" type=\"video/mp4\" />\nvideo\n</video>","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Default plot with 3D plot and error distribution for all points as well as allocation to planes for each plot (for Heuristic)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: )","category":"page"},{"location":"#Acknowledgements","page":"Introduction","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"TODO: Add project references.","category":"page"},{"location":"howto/approximate_points/#Approximate-points","page":"Approximate points","title":"Approximate points","text":"","category":"section"},{"location":"howto/approximate_points/","page":"Approximate points","title":"Approximate points","text":"For piecewise-affine approximations obtained from a dataset, the function FunctionEvaluations(ð’³, ð’µ) can be used to create a structure that contains a tuple with the points in the domain ð’³ and their corresponding function values ð’µ. The function approx will receive this struct as input to calculate the approximations that best fit the dataset.","category":"page"},{"location":"howto/approximate_points/#Unidimensional-funcions-(1D)","page":"Approximate points","title":"Unidimensional funcions (1D)","text":"","category":"section"},{"location":"howto/approximate_points/","page":"Approximate points","title":"Approximate points","text":"The following code creates a 2D full-order piecewise affine approximation for a tuple (x,z) where x is a collection of points with their corresponding function values stores in z. The selected approximation is convex, uses 5 planes (linear segments), and applies lâ‚-norm regulazation as the error measure.","category":"page"},{"location":"howto/approximate_points/","page":"Approximate points","title":"Approximate points","text":"using PiecewiseAffineApprox, JuMP, HiGHS\noptimizer = optimizer_with_attributes(HiGHS.Optimizer, MOI.Silent()=>true)\n\nx = collect(range(-1, 1; length = 10))\nz = x .^ 2\n\npwa = approx(\n    FunctionEvaluations(Tuple.(x), z),\n    Convex(),\n    MILP(;optimizer, metric = :l1, planes = 5),\n)\n\nlength(pwa.planes)\n\n# output\n5","category":"page"},{"location":"howto/approximate_points/#Bi-variate-functions-(3D)","page":"Approximate points","title":"Bi-variate functions (3D)","text":"","category":"section"},{"location":"howto/approximate_points/","page":"Approximate points","title":"Approximate points","text":"A dataset can also be used as input for 3D piecewise affine approximations. The following code creates a uniformly sampled domain X within (-1,1) and calculates the corresponding function values for a concave function z_concave.","category":"page"},{"location":"howto/approximate_points/","page":"Approximate points","title":"Approximate points","text":"using PiecewiseAffineApprox, JuMP, HiGHS\noptimizer = optimizer_with_attributes(HiGHS.Optimizer, MOI.Silent()=>true)\n\nxg = [i for i âˆˆ -1:0.5:1]\nyg = [j for j âˆˆ -1:0.5:1]\n\nX = [repeat(xg, inner = [size(yg, 1)]) repeat(yg, outer = [size(xg, 1)])]\n\nz = X[:, 1] .^ 2 + X[:, 2] .^ 2\nz_concave = z .* -1\n\nnp = 17\n\npwa = approx(\n    FunctionEvaluations(tuple.(eachcol(X)...), z),\n    Convex(),\n    MILP(\n        ;optimizer,\n        planes = np,\n        strict = :outer,\n        metric = :l1,\n    ),\n)\nlength(pwa.planes)\n\n# output\n17","category":"page"},{"location":"howto/plot_approximation/#Plot-approximation","page":"Plot approximations","title":"Plot approximation","text":"","category":"section"},{"location":"howto/plot_approximation/","page":"Plot approximations","title":"Plot approximations","text":"Some plotting functons are available for visualization of piecewise affine approximations using standard backend packages Makie or Plots. ","category":"page"},{"location":"howto/plot_approximation/#2D","page":"Plot approximations","title":"2D","text":"","category":"section"},{"location":"howto/plot_approximation/","page":"Plot approximations","title":"Plot approximations","text":"The following code shows how to the use of a plotting function with Makie:","category":"page"},{"location":"howto/plot_approximation/","page":"Plot approximations","title":"Plot approximations","text":"using PiecewiseAffineApprox, CairoMakie, HiGHS, JuMP\noptimizer = optimizer_with_attributes(HiGHS.Optimizer, MOI.Silent()=>true)\n\nx = LinRange(0, 1, 20)\nf(x) = first(x)^2\npwa = approx(f, [(0, 1)], Convex(), MILP(;optimizer, planes = 3))\np = plot(x, f.(x), pwa)\n\nsave(\"approx.svg\", p)\n# output\nCairoMakie.Screen{SVG}","category":"page"},{"location":"howto/plot_approximation/","page":"Plot approximations","title":"Plot approximations","text":"(Image: )","category":"page"},{"location":"howto/plot_approximation/#3D","page":"Plot approximations","title":"3D","text":"","category":"section"},{"location":"howto/plot_approximation/","page":"Plot approximations","title":"Plot approximations","text":"Default plot with 3D plot and error distribution for all points as well as allocation to planes for each plot (for Heuristic)","category":"page"},{"location":"howto/plot_approximation/","page":"Plot approximations","title":"Plot approximations","text":"using PiecewiseAffineApprox, CairoMakie, HiGHS, JuMP\nusing Logging\n\nwith_logger(NullLogger()) do\noptimizer = optimizer_with_attributes(HiGHS.Optimizer, MOI.Silent()=>true)\n\n\nI = 100\nxmat = 2 * rand(2, I) .- 1\nx = [Tuple(xmat[:, i]) for i = 1:size(xmat, 2)]\nz = [p[1]^2 + p[2]^2 for p in x]\nvals = FunctionEvaluations(x, z)\n\npwa = approx(\n    vals,\n    Convex(),\n    Cluster(; optimizer = HiGHS.Optimizer, planes = 9, strict = :none),    \n)\np = plot(vals, pwa)\n\nsave(\"approx_3D.png\", p)\nend\n\n# output\nCairoMakie.Screen{IMAGE}","category":"page"},{"location":"howto/plot_approximation/","page":"Plot approximations","title":"Plot approximations","text":"(Image: )","category":"page"}]
}
